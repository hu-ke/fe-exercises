<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
// 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

// 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

// 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。

// 来源：力扣（LeetCode）
// 链接：https://leetcode.cn/problems/kth-largest-element-in-an-array
// 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

// 其实 O(n) 不是绝对的，指的是平均复杂度。
        let arr = [3,2,1,5,6,4]
        // public int findKthLargest(int[] nums, int k) {
        //     int len = nums.length;
        //     int left = 0;
        //     int right = len - 1;
    
        //     // 转换一下，第 k 大元素的索引是 len - k
        //     int target = len - k;
    
        //     while (true) {
        //         int index = partition(nums, left, right);
        //         if (index == target) {
        //             return nums[index];
        //         } else if (index < target) {
        //             left = index + 1;
        //         } else {
        //             right = index - 1;
        //         }
        //     }
        // }
    
        /**
         * 在数组 nums 的子区间 [left, right] 执行 partition 操作，返回 nums[left] 排序以后应该在的位置
         * 在遍历过程中保持循环不变量的语义
         * 1、[left + 1, j] < nums[left]
         * 2、(j, i] >= nums[left]
         *
         * @param nums
         * @param left
         * @param right
         * @return
         */
        // public int partition(int[] nums, int left, int right) {
        //     int pivot = nums[left];
        //     int j = left;
        //     for (int i = left + 1; i <= right; i++) {
        //         if (nums[i] < pivot) {
        //             // 小于 pivot 的元素都被交换到前面
        //             j++;
        //             swap(nums, j, i);
        //         }
        //     }
        //     // 在之前遍历的过程中，满足 [left + 1, j] < pivot，并且 (j, i] >= pivot
        //     swap(nums, j, left);
        //     // 交换以后 [left, j - 1] < pivot, nums[j] = pivot, [j + 1, right] >= pivot
        //     return j;
        // }
    
        // private void swap(int[] nums, int index1, int index2) {
        //     int temp = nums[index1];
        //     nums[index1] = nums[index2];
        //     nums[index2] = temp;

    // ————————————————
    // 版权声明：本文为CSDN博主「大叶子不小」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
    // 原文链接：https://blog.csdn.net/qq_32907195/article/details/107077056
    </script>
</body>
</html>